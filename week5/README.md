# 🧩 문제 A — 제한된 메모리로 빠진 32비트 정수 찾기

## 1. 문제 정의

- 파일에는 **최대 40억 개**의 서로 다른 32비트 정수가 저장되어 있다.
- 정수 값의 범위는 **0 ~ 2³²−1** (총 약 43억 개).
- 이 중 **정확히 하나의 정수가 빠져 있다.**
- 입력 데이터는 **정렬되어 있지 않다.**
- **중복은 없다.**
- 사용할 수 있는 메모리는 **수백 바이트 정도로 매우 제한적**이다.
- 단, **임시 파일 몇 개는 사용할 수 있다.**

> 🎯 목표:  
> 정렬되지 않은 40억 개의 정수 파일에서  
> **극도로 작은 메모리만 가지고 누락된 정수 하나를 찾아라.**

---

## 2. 비트맵(bit map)이 불가능한 이유

비트맵을 사용하면 각 정수의 존재 여부를 한 비트로 표시해  
빠진 값을 매우 쉽게 찾을 수 있다.  

그러나 전체 범위를 비트맵으로 표현하려면  
약 **4,000,000,000 비트 → 512MB** 정도의 메모리가 필요하다.  
문제의 제한(수백 바이트) 내에서는 전혀 사용할 수 없는 방식이다.

따라서 메모리 대신,  
**정수 값의 ‘범위’ 자체를 이용해 빠진 값을 추론하는 전략**이 필요하다.

---

## 3. 핵심 아이디어 — 범위 기반 이진 분할 (Binary Partition by Range)

핵심은  
> “정렬 여부와 완전히 상관없이,  
> **값이 어느 구간에 속하는지만** 확인하면  
> 누락된 정수가 있는 범위를 좁힐 수 있다.”

전체 범위를 반으로 나누고,  
각 정수가 어느 구간에 속하는지만 세어보면  
**개수가 부족한 쪽이 곧 빠진 정수가 포함된 구간**임을 알 수 있다.  
이 원리를 반복하면 범위를 점점 좁힐 수 있다.

---

## 4. 알고리즘 개요

### ① 전체 범위를 절반으로 나누기
예: 전체 범위 `[0, 2³²)`  
중간값 `mid = 2³¹`

- 왼쪽 구간: `[0, 2³¹)`
- 오른쪽 구간: `[2³¹, 2³²)`

### ② 파일 전체를 순차 스캔하며 개수 세기
정렬 여부와 관계없이 파일을 처음부터 끝까지 읽으며:

- `x < mid` → `count_left++`
- `x ≥ mid` → `count_right++`

정상적으로라면 두 구간에 **각각 정확히 절반 개수의 값**이 있어야 한다.  
그러나 정수 하나가 빠져 있으므로  
**한쪽 구간만 정상 개수보다 1 적다.**

### ③ 누락된 값이 있는 구간 선택
- `count_left < expected_left_size` → 빠진 값은 `[low, mid)`  
- 그렇지 않으면 → `[mid, high)`

### ④ 선택된 구간으로 범위 좁히기  
새로운 범위에서 다시 mid를 계산하고  
파일 전체를 다시 스캔한다.  
이때는 **현재 범위 밖의 모든 값은 무시**한다.

### ⑤ 반복  
범위의 크기가 1이 될 때까지 위 과정을 반복한다.  
마지막 남은 단일 값이 바로 **빠진 정수**이다.

---

## 5. 중요한 특징

### ✔ 정렬이 필요 없다  
이 알고리즘은 정렬을 전혀 사용하지 않는다.  
각 값이 어느 구간에 속하는지만 확인하므로  
입력이 랜덤한 순서여도 정확히 동작한다.

### ✔ 메모리 사용량이 극히 낮다  
각 단계에서 필요한 것은 다음 네 가지뿐이다:

- `low`, `high`
- `mid`
- `count_left`, `count_right`

모두 합쳐봐야 **수십 바이트**에 불과하다.

### ✔ 파일 전체를 여러 번 스캔  
각 단계에서 파일을 처음부터 끝까지 다시 읽어야 한다.  
32비트 정수 범위를 로그₂로 좁히므로  
약 32번의 전체 스캔이면 충분하다.

### ✔ 시간 ↔ 공간 트레이드오프  
메모리는 거의 쓰지 않는 대신,  
**시간(여러 번의 파일 스캔)**을 지불한다.

---

## 6. 요약

> 🔎 **비트맵을 사용할 수 없을 만큼 메모리가 적어도**,  
> 빠진 정수는  
> **값의 범위를 절반씩 줄여가며 각 구간의 개수만 비교하는 방식으로** 찾을 수 있다.  
>  
> 이 방법은 입력이 정렬되어 있을 필요가 없으며,  
> 정수 하나가 빠졌다는 사실만으로  
> 빠진 값이 포함된 범위를 점진적으로 좁혀  
> 최종적으로 정확한 누락값을 찾을 수 있다.

---

# 🧩 문제 B — 벡터의 왼쪽 회전 (Left Rotation) 문제

## 1. 문제 정의

길이가 `n`인 벡터 `x`가 있다.  
이 벡터를 **왼쪽으로 `i`만큼 회전(left rotate)** 하고자 한다.  
즉, 벡터를 `x = a b` 로 나누었을 때,  

- `a` = 처음 `i`개의 원소  
- `b` = 나머지 `n - i`개의 원소  

왼쪽 회전의 목표는 **벡터 `ab` → `ba` 로 변환하는 것**이다.

여기서 요구 조건은 다음과 같다:

- 실행 시간은 **O(n)**, 즉 벡터 크기에 비례해야 한다.
- 사용할 수 있는 여분 메모리는 **수십 바이트 수준**이어야 한다.  
  (임시 배열을 크게 사용할 수 없음)

---

## 2. 단순한 접근 방법과 그 한계

### ❌ 방법 1: 처음 `i`개를 임시 배열에 저장하는 방식
1. `a`를 임시 배열에 복사한다. (여기서 임시 메모리 `i`개 필요)
2. `b`를 앞으로 이동한다.
3. 임시 배열의 `a`를 뒤쪽에 다시 붙인다.

→ 필요한 임시 공간이 **O(i)** 이므로 메모리 제한을 만족하지 못한다.

### ❌ 방법 2: 왼쪽 회전을 1번 수행하는 O(n) 함수를 `i`번 호출
회전을 1번 수행하는 데 `O(n)` 시간이 걸리므로  
이를 `i`번 수행하면 총 시간은 **O(n × i)**가 된다.

→ 시간 제약 위반.

---

## 3. 해결책 1 — 저글링 알고리즘 (Juggling algorithm)

저글링 알고리즘은 **임시 저장소 1개(t)**만 사용하여  
벡터 전체를 `O(n)` 시간에 회전시키는 방법이다.

핵심 아이디어:

- 인덱스 이동을 **“사이클(cycle)” 단위**로 처리하는 방식  
- 각 원소는 “자기 위치에서 i만큼 왼쪽으로 이동하는” 경로를 따라가며 재배치된다.

### 🔧 알고리즘 흐름

1. `x[0]`을 임시 공간 `t`에 저장한다.
2. `x[i]`를 `x[0]`로 옮긴다.  
3. `x[2i]`를 `x[i]` 자리에 옮긴다.  
4. `x[3i]` → `x[2i]` …  
   이런 식으로 **i 간격으로 점프하면서** 값을 이동시킨다.
5. 인덱스가 벡터 길이를 초과하면 modulo 연산으로 순환한다.
6. 처음 위치로 다시 돌아오면 cycle 하나가 끝나며, 마지막에 `t`를 제자리에 넣는다.
7. 다음 cycle을 위해 `x[1]`부터 같은 작업을 진행한다.
8. 모든 원소가 제자리를 찾을 때까지 반복한다.

### ✨ 특징

- 필요한 임시 공간은 단 1개 원소 크기 → **O(1) 메모리**
- 전체 원소를 **정확히 한 번씩만 이동** → **O(n) 시간**

---

## 4. 해결책 2 — 부분 교환(Block Swap) 알고리즘

왼쪽 회전은 결국 **두 블록 `a`와 `b`를 맞바꾸는 문제**로 볼 수 있다:
ab → ba


여기서 두 블록의 크기 관계에 따라 다음과 같이 처리한다.

### 🔧 핵심 아이디어

- `a`의 크기가 `b` 보다 작다고 하자.
- 그러면 `b`를 두 부분 `b_l` 과 `b_r` 로 나눌 수 있다.  
  (`b_r`의 길이가 `a`와 동일하도록)
- `a`와 `b_r`을 **swap** 한다.
- 그러면 `a`는 자기 최종 위치로 이동한다.
- 이제 남은 문제는 `b_l` 과 `a`(원래의 `b_r`)을 맞바꾸는 새로운 문제.
- 이 문제는 **구조가 완전히 동일하므로 재귀적으로 해결**할 수 있다.
- 전체 과정은 결국 O(n) 시간 안에 끝난다.

---

## 5. 해결책 3 — 세 번의 반전(Reversal)으로 해결하기

이 문제를 반전(reversal) 관점에서 보면 훨씬 더 단순한 알고리즘을 만들 수 있다.

### 🎯 핵심 통찰  
회전 `ab → ba` 는  
세 번의 반전만으로 동일하게 만들 수 있다.

1. 부분 `a`를 반전 → `a^r b`
2. 부분 `b`를 반전 → `a^r b^r`
3. 전체 `a^r b^r`를 반전 → `(a^r b^r)^r = ba`

즉,  
reverse(0, i-1)  
reverse(i, n-1)  
reverse(0, n-1)  
을 호출하면 벡터는 정확히 **i만큼 왼쪽 회전한 결과**가 된다.

### ✨ 장점
- 반전 연산은 **두 인덱스를 교환(swap)하는 방식**으로 구현할 수 있으므로  
  **O(1) 메모리 / O(n) 시간**을 만족한다.
- 실제 구현도 매우 간단하다.

---

## 6. 요약

> 이 문제는 “왼쪽 회전”이라는 단순한 연산이지만,  
> **O(n) 시간, O(1) 추가 메모리**라는 제약 때문에  
> 일반적인 방법(임시 배열 사용, 반복 회전)으로는 해결할 수 없다.  
>
> 해결책은 크게 세 가지이며 모두 O(n)/O(1)을 만족한다:
>
> - **저글링(Juggling) 알고리즘:** 인덱스 사이클 기반의 원소 재배치  
> - **블록 교환(Block Swap) 알고리즘:** 부분 블록 swap을 반복  
> - **3-반전(Reversal) 알고리즘:** 반전 3번으로 ab → ba를 구현  
>
> 이 세 알고리즘 모두 “인접한 메모리 블록의 재배치”라는 문제를  
> 최소한의 메모리로 해결하는 대표적인 기법이다.

# 🧩 문제 C — 전철어(anagram) 집합 찾기

## 1. 문제 정의

영어 단어 사전에서, 서로 **철자의 순서만 다르고 동일한 문자들로 구성된 단어들**, 즉 전철어(anagram) 집합을 모두 찾아내는 문제이다.  
예를 들어, `pots`, `stop`, `tops`는 문자 순서만 다를 뿐 동일한 문자 집합으로 이루어져 있으므로 서로 전철어 관계이다.

가장 단순한 접근은 단어 내의 문자들이 만들 수 있는 모든 순열을 생성하여 비교하는 방식이지만, 길이가 n인 단어는 n!개의 순열을 가지므로 현실적으로 불가능할 정도로 느리다.  
따라서 효율적인 전철어 분류를 위해 더 나은 방식이 필요하다.

---

## 2. 핵심 아이디어 — “같은 부류의 단어는 같은 표시를 갖는다”

전철어 판별을 효율적으로 수행하기 위해, 사전에 있는 **각 단어에 하나의 '표시(signature)'를 부여**하고,  
이 표시가 **전철어 관계인 단어들끼리 동일하게** 정의되도록 만드는 방식이 유용하다.

문제는 두 부분으로 나뉜다:

1. 각 단어에 대해 어떤 표시(signature)를 부여할 것인가  
2. 동일한 표시를 가진 단어들을 어떻게 모을 것인가

표시만 잘 정의하면, 이후에는 단순히 “같은 표시를 가진 단어들을 그룹으로 묶기”만 하면 된다.

---

## 3. 표시(signature)를 만드는 대표적인 방법들

### ① 단어 내의 문자를 정렬한 결과를 표시로 사용
단어의 문자를 알파벳 순으로 정렬한 문자열은 전철어 집합 전체에서 동일하다.

- 예:  
  - `deposit` → `deiopst`  
  - `dopi​est` → `deiopst`  
  이 두 단어의 표시는 동일하므로, 같은 전철어 집합에 속한다.

이 방식은 간단하며, 정렬만 수행하면 되므로 널리 사용된다.

---

### ② 문자 개수 기반의 표시

전철어는 동일한 알파벳으로 이루어지므로, **각 문자별 등장 횟수 배열**로도 표시할 수 있다.

예시:

- `Mississippi`  
  - i: 4회  
  - m: 1회  
  - p: 2회  
  - s: 4회  

이를 문자열로 표현하면 `i4m1p2s4`, 또는 1은 생략해 `i4mp2s4`처럼 간소화할 수도 있다.

또는 a~z까지 **26개의 정수로 이루어진 배열**을 사용해 문자 빈도를 직접 기록할 수도 있다.  
이 방식은 지문(FBI fingerprint indexing)이나 발음 기반 이름 탐지(soundex heuristic)에서도 활용되는 방식이다.

---

## 4. 같은 표시를 가진 단어들을 모으는 과정

표시가 정의되면 전철어 문제는 다음처럼 단순해진다.

- 모든 단어에 대해 표시(signature)를 계산한다.
- 단어들을 이 표시 기준으로 정렬하거나,  
  혹은 해시 테이블로 묶는다.
- 같은 표시를 공유하는 단어들을 같은 그룹으로 모으면  
  그것이 바로 전철어 집합이다.

즉, 정렬은 이 문제의 목적이 아니라  
**동일한 종류의 원소를 모으기 위한 ‘수단’**으로 사용된다.

---

## 5. 표시(signature)가 중요한 이유

전철어처럼 “동치 관계(equivalence relation)”로 정의되는 문제에서는  
각 집합의 원소들이 공유하는 **공통된 대표값(representative)** 을 정의해두면  
문제를 단순화할 수 있다.

- 같은 동치 관계에 있는 원소들은 같은 표시를 갖는다.  
- 동치 관계가 아닌 원소들은 서로 다른 표시를 가져야 한다.

문자 정렬 또는 문자 빈도 기반의 표시는  
이런 대표값을 만드는 데 매우 적절한 기법이다.

---

## 6. 문제 해결 능력에 대한 교훈

훌륭한 프로그래머는 때로는 ‘게으른’ 태도를 취한다.  
즉, 복잡한 힘을 들이기 전에 문제를 깊이 분석하고,  
더 단순하고 본질적인 해결책을 찾기 위해 시간을 쓴다.

하지만 분석만 하다가 끝날 수는 없고,  
적절한 시점에 구현을 시작하는 균형 감각이 중요하다.  
이 적절한 시점과 방향 감각은 다양한 문제를 직접 해결하고 구현하는 경험을 통해 얻어진다.

---

## 7. 요약

- 전철어를 찾기 위해 문자 순열을 모두 생성하는 것은 비효율적이다.
- **같은 부류의 단어들이 동일한 표시(signature)를 갖도록 정의**하면 문제는 크게 단순해진다.
- 단어의 문자를 정렬한 결과나 문자 빈도 배열 등을 표시로 사용할 수 있다.
- 같은 표시를 갖는 단어들을 정렬하거나 해싱하면 전철어 집합을 쉽게 찾을 수 있다.
- 이는 "동치 관계의 집합을 대표하는 값"을 잘 정의하는 전형적인 문제 해결 전략이다.
  
---

# 🧩 문제 C 연습문제 해설

## 1. 단어 하나에 대한 전철어(anagram) 찾기

### 문제
- 입력: 영어 단어 하나와, 영어 단어 사전(단어 리스트)
- 출력: 입력된 단어와 전철어 관계인 모든 단어
- 전처리 없이 “입력 단어 + 사전”만으로 푸는 경우와,
- 사전에 대해 미리 전처리할 수 있는 경우를 생각하라.

### 1-1) 전처리 없이 바로 푸는 방법

아이디어:  
입력 단어와 사전의 각 단어에 대해 **“정렬된 문자열”**을 비교하면 된다.

1. 입력 단어 `w`의 문자들을 알파벳 순으로 정렬하여 `sig(w)`를 만든다.
   - 예: `deposit` → `deiopst`
2. 사전의 각 단어 `d`에 대해:
   - 길이가 `w`와 다르면 전철어일 수 없으므로 건너뛰기
   - 길이가 같다면, `d`의 문자들을 정렬해 `sig(d)`를 만든다.
   - `sig(d) == sig(w)`이면 `d`는 `w`의 전철어이다.
3. 모든 사전에 대해 이 과정을 수행하며 전철어들을 수집한다.

특징:
- 비교 기준이 “정렬된 문자열”이므로 순열을 전부 생성할 필요가 없다.
- 단점: 입력마다 사전 전체를 한 바퀴 돌며 각 단어를 정렬해야 한다.

---

### 1-2) 사전을 미리 전처리할 수 있는 경우

아이디어:  
사전에 있는 모든 단어에 대해 **미리 signature(표시)** 를 계산해두고,  
같은 signature를 가지는 단어들을 “버킷”으로 묶어두면,  
나중에는 signature로 바로 찾을 수 있다.

전처리 단계:
1. 사전에 있는 각 단어 `d`에 대해:
   - `sig(d)` = 정렬된 문자열, 또는
   - 26개 알파벳에 대한 등장 횟수 배열 등
2. `(sig(d) → 단어 목록)` 형태의 맵(map) 또는 해시 테이블을 만든다.

질의(입력 단어 w가 들어왔을 때):
1. `sig(w)`를 계산한다.
2. 맵에서 `sig(w)`를 키로 조회한다.
3. 해당 버킷에 있는 단어들이 모두 `w`의 전철어이다.

특징:
- 전처리에 O(사전크기 × 단어길이 log 단어길이) 정도의 시간이 들지만,
- 이후 질의는 거의 O(단어길이 log 단어길이) + 해시 조회 시간으로 해결된다.
- 많은 개수의 질의를 처리할 때 매우 효율적이다.

---

## 2. 4,300,000,000개의 32비트 정수 중 두 번 이상 나타나는 정수 찾기

### 문제
- 순차적 파일에 32비트 정수가 약 4.3억이 아니라 **4.3 billion(4,300,000,000)** 개 들어 있다.
- 32비트 정수의 전체 가능한 값은 약 4.29 billion(2³² ≈ 4.29×10⁹) 개이므로,
  비둘기집 원리에 의해 **반드시 중복 값이 하나 이상 존재한다.**
- 목표: 그 중 **한 개 이상의 중복 정수**를 찾아라.
- 메모리는 제한적이고, 파일은 디스크에 순차적으로 존재한다고 가정.

### 핵심 아이디어

32비트 값 전체 범위를 한 번에 메모리에 담을 수 없으므로,  
값의 범위를 여러 구간으로 나누고,  
각 구간 내에 “기대되는 개수보다 더 많이 등장하는 구간”을 찾은 다음,  
그 구간 안에서 비트맵 등으로 중복을 찾는 방식이다.

### 단계별 설명

1. **값의 범위를 여러 블록으로 분할**
   - 예: 전체 0 ~ 2³²−1 범위를 M개 구간으로 나누기.
   - 각 구간의 크기를 “메모리로 관리 가능한 수량”에 맞춘다.

2. **1차 패스: 각 구간에 속하는 정수 개수 세기**
   - 파일을 처음부터 끝까지 한 번 스캔한다.
   - 각 정수 `x`에 대해, `x`가 속하는 구간의 카운터를 증가시킨다.
   - 정상적으로 **중복이 전혀 없다면**, 각 구간의 카운트는 해당 구간에 포함될 수 있는 서로 다른 값의 개수를 넘지 못한다.
   - 어떤 구간에서 카운트가 “해당 구간에서 표현 가능한 서로 다른 값 개수”를 초과한다면,
     그 구간에는 **중복된 값이 존재한다.**

3. **중복이 있는 구간 선택**
   - 카운트가 “가능한 서로 다른 값의 수”보다 큰 구간 중 하나를 고른다.
   - 이 구간 내에서만 중복 탐색을 수행하면 된다.

4. **2차 패스: 선택된 구간에 대해 비트맵/표시를 사용**
   - 선택된 구간의 값 범위는 메모리에 비트맵 등으로 관리 가능한 크기여야 한다.
   - 해당 구간에 다시 한 번 파일을 스캔하며:
     - 범위 밖 값은 무시한다.
     - 범위 안의 값에 대해:
       - 처음 보는 값이면 비트를 1로 설정.
       - 이미 비트가 1이면 → **이 값이 바로 중복 값 중 하나**이다.

이 방식은:
- 첫 번째 패스에서는 범위별 개수만 세고,
- 두 번째 패스에서는 선택된 작은 범위 내에서만 비트맵을 쓰므로,
- 전체 32비트 범위를 비트맵으로 다 표현하지 않고도 중복 값을 찾을 수 있다.

---

## 3. 두 가지 벡터 회전 알고리즘 구현과 최대공약수의 역할

앞에서 배운 대표적인 두 가지 벡터 회전 알고리즘:

1. 저글링(juggling) 알고리즘
2. 세 번의 반전(reversal) 알고리즘

### 3-1) 저글링 알고리즘 구현 개요

- 길이 n인 배열을 왼쪽으로 i만큼 회전한다고 하자.
- `g = gcd(n, i)`라 두면, 배열의 인덱스들은 **g개의 사이클**로 나뉜다.
- 각 사이클마다 원소들을 돌려가며 이동시키면 전체 회전이 완성된다.

의사코드 개념:

```text
g = gcd(n, i)
for s in 0 .. g-1:
    temp = x[s]
    j = s
    while True:
        k = (j + i) mod n
        if k == s: break
        x[j] = x[k]
        j = k
    x[j] = temp
```
여기서 gcd(n, i)는:

사이클의 개수를 의미하고,

각 사이클의 길이는 n / g가 된다.

모든 원소가 정확히 한 번씩 이동되도록 보장하는 핵심 값이다.

### 3-2) 반전(Reversal) 알고리즘 구현 개요

배열의 앞쪽 i개, 뒤쪽 n-i개, 전체 배열 세 부분에 대해 반전을 수행한다.

의사코드 개념:
```text
reverse(x, 0, i-1)
reverse(x, i, n-1)
reverse(x, 0, n-1)
```

각 reverse 함수는 주어진 구간의 앞뒤에서부터 원소를 하나씩 swap해 나가는 단순한 구현이다.

이 알고리즘에서는:

gcd(n, i)가 직접적으로 사용되지 않는다.

어떤 i, n에 대해서도 항상 올바르게 작동하며,
로직은 “반전의 성질”에 의존할 뿐, 최대공약수와는 무관하다.

### 정리

저글링 알고리즘: gcd(n, i)가 사이클 개수로 등장하며, 구현의 핵심 수학적 기반이다.

반전 알고리즘: gcd(n, i)는 직접적으로 사용되지 않으며, 알고리즘은 항상 세 번의 반전만으로 동작한다.

---

## 4. 벡터 회전 함수로 `abc`를 `cba`로 변환하는 방법

### 문제 요약
벡터를 두 부분으로 나누어 앞부분과 뒷부분을 서로 교환해주는 **회전 함수**가 있다고 하자.  
즉, 벡터를 `a | b`로 나누었을 때, 이 회전 함수는 이를 `b | a`로 바꿔주는 기능을 한다.

이제 벡터가 세 부분 `a | b | c`로 되어 있을 때,  
이 회전 함수만 사용해서 전체를 `c | b | a` 형태로 만들고자 한다.

### 해결 아이디어
회전 함수는 “두 블록을 교환하는” 기능이므로,  
세 블록 `a b c`를 원하는 순서 `c b a`로 만들기 위해서는  
적절한 구간을 두 번 교환하면 된다.

### 단계별 정리

#### ① 첫 번째 회전: `(ab) | c` 구간 교환
- 벡터를 `(ab)`와 `c` 두 부분으로 본다.
- 회전 함수 적용 → `c | ab`

예시 흐름: abc → cab


#### ② 두 번째 회전: `a | b` 구간 교환
이제 전체는 `c | ab` 형태이다.  
뒤쪽 부분 `ab`만 다시 두 부분 `a | b`로 나누어 회전 함수를 적용한다.

- `ab` → `ba`
- 전체 결과: `c | ba`

즉, cab → cba


### 결론
두 블록 교환 함수(회전 함수)를  
1) (ab)–c  
2) a–b  
두 구간에 대해 연속 두 번 적용하면  
**abc → cba** 변환을 만들 수 있다.

---

## 5. 실수 집합 A에서 “합이 t 이하인 k개 부분집합”이 존재하는지 빠르게 판별하는 방법

### 문제 요약
- A: n개의 실수로 이루어진 집합  
- t: 실수  
- k: 정수  
- 목표: A에서 **정확히 k개의 원소를 가지며 합이 t 이하인 부분집합**이 존재하는지 확인하라.

### 중요한 가정
A의 모든 원소가 **0 이상(비음 아님)**이라고 가정하면 문제는 매우 단순해진다.  
음수가 허용되면 이 문제는 일반적인 subset-sum 문제의 변형이 되어 NP-난도가 된다.

여기서는 **모두 0 이상**인 특수한 경우를 다룬다.

### 핵심 아이디어
합을 최소로 만들기 위해서는 **가장 작은 k개의 원소를 고르는 것이 최선**이다.  
(모든 값이 0 이상이므로 더 큰 값을 선택하면 합도 반드시 증가한다.)

### 알고리즘

1. A를 오름차순으로 정렬한다.
2. 정렬된 A에서 가장 작은 k개의 값을 선택한다.
3. 그 k개의 합을 구한다.
4. 다음을 판정한다:
   - 합 ≤ t 이면 → 조건을 만족하는 부분집합 **존재**
   - 합 > t 이면 → 어떤 k개 부분집합도 조건을 만족할 수 **없다**

### 시간 복잡도
- 정렬: O(n log n)
- k개 합 구하기: O(k) ≤ O(n)
- 전체: **O(n log n)**
