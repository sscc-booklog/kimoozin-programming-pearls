# 외부 정렬 (External Sorting) 및 비트맵 정렬 (Bit-map Sort)

> 제한된 메모리(≈1 MB) 환경에서 최대 1천만 개의 서로 다른 7자리 정수를 디스크 기반으로 정렬하는 문제를 다룬다.  
> 본 문서는 교재의 “40-패스 알고리즘”과 “비트맵 정렬” 방식을 비교‧분석한다.

---

## 1. 문제 개요

- **입력:**  
  최대 `10⁷`(1천만)개의 서로 다른 7자리 **양의 정수**
- **출력:**  
  오름차순 정렬된 정수 리스트
- **제약:**  
  메모리 약 **1 MB**, 디스크 공간은 충분  
- **조건:**  
  - 모든 값은 `0 ≤ x < 10⁷`  
  - **중복 없음** (중복은 치명적 오류)  
  - 정수 이외의 부가 데이터 없음  

---

## 2. 외부 병합정렬 (External Merge Sort)

### 💡 개념
메모리에 올릴 수 있는 크기만큼 데이터를 읽어 **부분 정렬(run)** 파일을 생성하고,  
그 후 여러 run 파일을 병합(merge)하여 최종 정렬본을 만든다.

### ⚙️ 단계별 과정
1. **입력파일 1회 읽기:**  
   메모리 크기 단위로 나누어 각 부분을 정렬 → run 파일 생성
2. **병합 과정:**  
   여러 run 파일을 반복적으로 병합하며 새 run 생성
3. **최종 출력:**  
   모든 run 병합 완료 후 1개의 정렬된 파일 출력

### I/O 특성
| 구분 | 설명 |
|------|------|
| 입력 읽기 | 1회 |
| 중간파일(run) | 여러 개 생성 |
| 병합 I/O | 여러 번 읽기/쓰기 반복 |
| 출력 파일 | 최종 1회 생성 |

---

## 3. 40-패스 알고리즘

### 배경
- 1 MB 메모리로는 약 **25만 개(=1,000,000 B / 4 B)** 의 정수만 저장 가능  
- 전체 1천만 개를 처리하려면 **40번(10⁷ ÷ 25만)** 의 패스 필요

### 동작 원리
1. 전체 정수 범위를 **40개의 구간**으로 균등 분할  
   - 1패스: `[0, 249 999]`  
   - 2패스: `[250 000, 499 999]`  
   - …  
   - 40패스: `[9 750 000, 9 999 999]`
2. 각 패스마다  
   - 입력파일 전체를 스캔하면서 **해당 범위의 값만 메모리에 적재**
   - 메모리 내에서 정렬
   - 결과를 **최종 출력파일에 append**
3. 모든 범위를 순차적으로 처리하면 출력파일은 자연스럽게 **완전 정렬 상태**

### 📂 I/O 구조
```text
입력파일 (input)
├─> [패스1] 범위 0~249999 정렬 → 출력 append
├─> [패스2] 범위 250000~499999 정렬 → append
...
└─> [패스40] 범위 9750000~9999999 정렬 → append
⇒ 최종 정렬된 출력파일 완성
```

### 특징 요약
| 항목 | 설명 |
|------|------|
| 입력 읽기 횟수 | 40회 |
| 출력 쓰기 | 1회 (append 방식) |
| 중간파일 | 없음 |
| 병합 과정 | 불필요 |
| 장점 | 구현 단순, 중간 저장 불필요 |
| 단점 | 입력 스캔이 많음 (40 pass) |

---

## 4. 비트맵 정렬 (Bit-map Sort)

### 💡 핵심 아이디어
각 정수의 **존재 여부만** 비트로 표현하면 정렬이 필요 없다.  
비트 인덱스 자체가 정렬 순서를 의미하기 때문이다.

### ⚙️ 알고리즘 3단계
1. **비트맵 초기화:**  
   - `10⁷`개의 비트를 0으로 초기화  
   - 메모리 약 `10⁷ / 8 = 1.25 MB`
2. **입력 스캔:**  
   - 입력파일을 한 번 읽으며 각 정수 `i`에 대해 `bit[i] = 1`  
   - 이미 1이면 → 중복 에러
3. **출력 생성:**  
   - 비트 0 → 9,999,999 순서로 스캔  
   - `bit[i] == 1`이면 `i`를 출력파일에 기록  
   → 자동으로 오름차순 정렬 결과 완성

### 메모리 계산
```text
10,000,000 bits ÷ 8 = 1,250,000 bytes ≈ 1.25 MB
```

기본 메모리가 약 1MB인데, 여기에 2백만 비트(약 0.25MB)의 여유가 추가되어
총 1.25MB를 사용할 수 있으므로,
1천만 비트(≈1.25MB) 크기의 전체 비트맵을 메모리에 한 번에 올릴 수 있다.
따라서 입력 한 번, 출력 한 번으로 처리가 가능하다.

---

# 💡 비트 벡터(Bit Vector)의 비트연산 구현

비트 벡터는 여러 개의 불리언 값을 0과 1 비트로 압축해 저장하는 자료구조다.  
각 비트는 **특정 인덱스의 원소가 존재하는가 여부**를 나타낸다.

## ⚙️ 구현 아이디어
- 비트 벡터를 `uint32_t` 또는 `uint64_t` 배열로 구성  
- 각 원소(워드)는 `32` 또는 `64`개의 비트를 담는다.  
- 인덱스 `i`에 해당하는 비트는 다음으로 계산할 수 있다:
  ```c
  word_index = i / WORD_SIZE;        // 몇 번째 워드인지
  bit_mask   = 1u << (i % WORD_SIZE); // 워드 내 비트 위치

### 🔧 기본 연산 (비트 연산 이용)

| 연산 | 의미 | 비트 연산식 |
|------|------|--------------|
| `set(i)` | i번째 비트를 1로 설정 | `arr[word_index] |= bit_mask;` |
| `clear(i)` | i번째 비트를 0으로 설정 | `arr[word_index] &= ~bit_mask;` |
| `test(i)` | i번째 비트가 1인지 검사 | `(arr[word_index] & bit_mask) != 0` |
| `toggle(i)` | i번째 비트를 반전 | `arr[word_index] ^= bit_mask;` |

---

## 🏁 결론 및 교훈

> 작은 문제에 대한 **주의 깊은 분석**이 때로는 **엄청난 실질적 이익**을 가져올 수 있다.  
> 본 사례에서는 몇 분간의 신중한 고찰만으로  
> 코드 길이, 프로그래머의 작업 시간, 그리고 실행 시간을 **10배 이상 단축**할 수 있었다.

### 💡 시간–공간 트레이드오프에 대한 통찰
프로그래밍에서는 흔히 **시간과 공간의 트레이드오프(time–space trade-off)** 가 존재한다.  
하지만 실제 경험상, **사용 공간을 줄이면 실행 시간도 함께 단축되는 경우가 많다.**

비트맵(bit map) 구조처럼 **공간을 효율적으로 사용하는 설계**는  
정렬 시간을 크게 줄이는 효과를 가져왔다.  
이러한 결과가 가능한 이유는 다음과 같다:
1. **데이터가 적으면 처리해야 할 양도 줄어든다.**  
   → 연산 횟수 및 루프 반복 수 감소.
2. **데이터를 디스크가 아닌 메모리에 보관한다.**  
   → 디스크 접근(Seek 및 I/O) 오버헤드를 회피.

물론, 이러한 개선이 가능했던 것은  
**기존 설계가 최적화되어 있지 않았기 때문**이기도 하다.  
그러나 이 예시는,  
> “세밀한 문제 분석과 단순한 아이디어만으로도  
> 프로그램의 성능과 효율을 획기적으로 개선할 수 있다”  
는 사실을 잘 보여준다.

